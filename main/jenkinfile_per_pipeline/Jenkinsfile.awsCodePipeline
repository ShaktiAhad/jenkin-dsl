@Library('pipeline-library') _
import groovy.json.JsonSlurperClassic
import groovy.json.JsonBuilder

def param = new JsonSlurperClassic().parseText(env.PARAMS_STR)
version = params.releaseVersion
awsCodePipeline = param.awsCodePipeline

region = awsCodePipeline.region
repo = awsCodePipeline.codeCommitRepo
cfStack = awsCodePipeline.cfStack
pipeline = awsCodePipeline.codePipeline
rule = awsCodePipeline.eventRule

node('master'){
    cfStackParams = awsDescribeStack(region, cfStack)["Stacks"]["Parameters"][0]
    branchName = cfStackParams.find {it.'ParameterKey' == "BucketPrefix"}
    branchValue = "${branchName.'ParameterValue'}"

    stage('prepraration'){
        println "--> prepraration stage"
        def common = param.common
        checkout scm: [$class: 'GitSCM', userRemoteConfigs: [[url: common.gitUrl, credentialsId: common.cred]], branches: [[name: "refs/heads/${common.branch}"]]], poll: false
    }

    stage('change event rule status'){
        println "--> change event rule status"
        timeout(time: 2, unit: 'MINUTES') {
            change_eventRule_status = input message: "User input required",
                parameters: [choice(name: 'Change eventRule status', choices: ['enable', 'disable'], description: 'Choose "disable" if you want to disable eventRule status')]
        }
        if (change_eventRule_status == "disable"){
            awsDisableEventRule = awsDisableEventRule(region, rule)
            sleep(7)
            awsDescribeEventRule = awsDescribeEventRule(region, rule)
            println ("Rule_name: "+awsDescribeEventRule["Name"]+ ", Status: "+awsDescribeEventRule["State"])
        }
        else {
            awsEnableEventRule = awsEnableEventRule(region, rule)
            sleep(7)
            awsDescribeEventRule = awsDescribeEventRule(region, rule)
            println ("Rule_name: "+awsDescribeEventRule["Name"]+ ", Status: "+awsDescribeEventRule["State"])
        } 
    }

    stage('proceed for release'){
        timeout(time: 60, unit: 'MINUTES') {
            input message: "proceed for release?"
        }
    }

    stage('check release branch on codeCommit'){
        println "--> check release branch on codeCommit stage"
        branch_name = awsCodeCommitBranchCheck(region, repo, version)
    }

    stage('Update CF template and get stack events'){
        println "--> Update CF template and get stack events stage"
        if (branchValue != "${env.bucket}"){
            branchName.'ParameterValue' = "${env.bucket}"
            param_json = new JsonBuilder(cfStackParams).toPrettyString()
            def updateCFtemplate = load ("${WORKSPACE}/main/jenkinfile_stage/Jenkinsfile.stage.updateCFtemplate")
            updateCFtemplate(region, cfStack, param_json)
        }
        else{
            println ("--> exisiting and requested value is same. Proceeding code pipeline deploy stage")
        }
    }

    stage('execute code pipeline & get pipeline status'){
        println "--> execute code pipeline & get pipeline status stage"
        def execCodePipeline = load("${WORKSPACE}/main/jenkinfile_stage/Jenkinsfile.stage.execCodePipeline")
        execCodePipeline(region, pipeline)
    }    

    stage('workspace cleanup'){
        cleanWs()
    }
}